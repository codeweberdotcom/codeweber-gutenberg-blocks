# GUTENBERГ-БЛОКИ · Требования и чек-листы

## 1. Структура блока
| Файл | Назначение |
|------|------------|
| `src/blocks/<block-name>/block.json` | Источник правды: `name`, `title`, `attributes`, `supports`, `style`. |
| `index.js` | Регистрация блока (импорт `edit`, `save`, стилей). |
| `edit.js` | Логика редактора, Inspector Controls. |
| `save.js` | Статический вывод (если блок сохранён на фронте). Для динамических блоков возвращаем `null`. |
| `style.scss` | Общие стили, грузятся на фронте. |
| `editor.scss` | Стили только для редактора. |

## 2. Регистрация и PHP-обвязка
- Каждый блок прописывается в `src/blocks/index.js` и экспортируется в `build/blocks`.
- Динамические блоки требуют `register_block_type` в PHP (`inc/Plugin.php`) и `render_callback`.
- Скрипты и стили подключаем через `wp_register_script/style` с зависимостями `wp-blocks`, `wp-i18n`, `wp-element`, `wp-editor`.
- Не грузим ассеты глобально: используем `enqueue_block_assets`/`enqueue_block_editor_assets` или автоматическую загрузку от `block.json`.

## 3. Атрибуты и миграции
- Атрибуты живут в `block.json`. Названия в camelCase, строковые значения — с дефолтами.
- При изменении структуры сохраняем совместимость:
  - добавляем `deprecated` массив в `index.js`,
  - описываем миграцию в `doc/GUTENBERG_BLOCK_STANDARDS.md` (отдельный под-раздел).
- Для динамических данных используем `useEntityProp`, `withSelect`, REST API или `fetch`.

## 4. UX и настройки
- Inspector Controls группируем в панели: `PanelBody`, `PanelRow`.
- Опции, которые связаны с фронтом, должны отображаться в реальном времени в редакторе.
- Все подписи/подсказки проходят через `__()` / `sprintf` из `@wordpress/i18n`.
- Для репитера или сложных полей предпочтительно использовать `@wordpress/components` (`RepeaterControl` заменяем на клиентский компонент при необходимости).

## 5. Стили и responsive
- Префикс классов: `cwgb-` или `codeweber-`.
- SCSS делим на частичные файлы при крупной логике и импортируем в `style.scss`.
- Mobile-first, breakpoint-ы равняются сетке темы (576/768/1024/1280).
- Для inline-стилей используем CSS custom properties (например, цвета из Color Palette).

## 6. Доступность (A11y)
- Используем семантические теги (`figure`, `section`, `nav`).
- Управляемые элементы (`Button`, `ToggleControl`) должны иметь `aria-label` и `help`-текст.
- Фокус-стили не убираем. Если дизайн требует, переопределяем, но оставляем видимыми.
- Поддерживаем клавиатурную навигацию в Inspector и на фронте.

## 7. Performance & Assets
- Избегаем динамического импорта крупных библиотек без необходимости.
- Если блок тянет внешний API — добавляем кеширование (WP transient, REST кеш) в PHP-слое.
- Изображения — через `wp_get_attachment_image` или `Image` компонент, с `loading="lazy"`.
- Лишние зависимости (`lodash`, `moment`) заменяем на `@wordpress/date` или нативный JS.

## 8. Тесты и проверка
- Smoke-тест в Gutenberg: вставить, настроить, удалить, вернуть (undo/redo).
- Фронт: проверить на странице и в шаблоне архива (если блок совместим).
- Локализация: переключить язык на `ru_RU`, убедиться в переводах.
- Ресурсные тесты: Lighthouse ≥ 90 для блока в отдельной странице (без тяжёлых ассетов).

## 9. Обновление документации
- Для каждого нового блока добавляем краткое описание (название, назначение, ключевые настройки) в отдельный раздел ниже.
- Если блок использует внешние API/настройки темы — описываем зависимости и fallback.

---

### Каталог блоков (дополняйте по мере работы)

| Блок | Тип | Особенности | Документация |
|------|-----|-------------|--------------|
| _Пример: Hero Banner_ | Статический | Фоновое изображение, CTA, поддержка `alignwide` | `doc/blocks/hero-banner.md` |

